unit TestctsPointerStructure;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, ctsTypesDef, ctsBaseInterfaces, ctsCommons, ctsObserver, 
  ctsPointerStructure, ctsBaseClasses, ctsSyncObjects, ctsMemoryPools, 
  ctsPointerInterface, Test_data;

type
  // Test methods for class TctsVector
  
  TestTctsVector = class(TTestCase)
  private
    FctsVector: TctsVector;
    FFileName: string;
    FOutPut: Text;
    procedure AddData;
    procedure DisposeProc(AData: Pointer);
  public
    function Compare(AData1, AData2 : Pointer): LongInt;
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAdd;
    procedure TestClear;
    procedure TestContain;
    procedure TestDelete;
    procedure TestFirst;
    procedure TestGetArray;
    procedure TestIndexOf;
    procedure TestInsert;
    procedure TestIsSorted;
    procedure TestLast;
    procedure TestPack;
    procedure TestRemove;
    procedure TestSort;
  end;
  // Test methods for class TctsLinkedList
  
  TestTctsLinkedList = class(TTestCase)
  private
    FctsLinkedList: TctsLinkedList;
    FFileName: string;
    FOutPut: Text;
    procedure AddData;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestAdd;
    procedure TestClear;
    procedure TestContain;
    procedure TestDeleteNode;
    procedure TestFirst;
    procedure TestGetHead;
    procedure TestGetTail;
    procedure TestInsertNode;
    procedure TestIsSorted;
    procedure TestLast;
    procedure TestPack;
    procedure TestRemove;
    procedure TestSort;
  end;
  // Test methods for class TctsStackVector
  
  TestTctsStackVector = class(TTestCase)
  private
    FctsStackVector: TctsStackVector;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestPop;
    procedure TestPush;
    procedure TestTop;
  end;
  // Test methods for class TctsStackLinked
  
  TestTctsStackLinked = class(TTestCase)
  private
    FctsStackLinked: TctsStackLinked;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestPop;
    procedure TestPush;
    procedure TestTop;
  end;
  // Test methods for class TctsQueueVector
  
  TestTctsQueueVector = class(TTestCase)
  private
    FctsQueueVector: TctsQueueVector;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestBack;
    procedure TestFront;
    procedure TestPop;
    procedure TestPush;
  end;
  // Test methods for class TctsQueueLinked
  
  TestTctsQueueLinked = class(TTestCase)
  private
    FctsQueueLinked: TctsQueueLinked;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestBack;
    procedure TestFront;
    procedure TestPop;
    procedure TestPush;
  end;

implementation

uses
  SysUtils,
  Math;

procedure TestTctsVector.AddData;
var
  I, Num: LongInt;
begin
  Randomize;
  for I := 0 to $FFFF do
  begin
    Num := RandomRange(100000, 50000000);
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(Num));
    FctsVector.Add(Pointer(Num));
  end;
end;

function TestTctsVector.Compare(AData1, AData2 : Pointer): LongInt;
begin
  Result := Integer(AData1) - Integer(AData2);
end;

procedure TestTctsVector.DisposeProc(AData: Pointer);
begin
  Writeln(FOutput, IntToStr(LongInt(AData)) + ': Deleting');
end;

procedure TestTctsVector.SetUp;
begin
  FctsVector := TctsVector.Create;
  FFileName := ExtractFilePath(ParamStr(0)) + 'Logs\Ptr_Vector_Test.log' ;
  ForceDirectories(ExtractFilePath(FFileName));
  AssignFile(FOutput, FFileName);
  if FileExists(FFileName) then
    Append(FOutput)
  else
    Rewrite(FOutput);
//  Writeln(FOutPut, FFileName);
end;

procedure TestTctsVector.TearDown;
begin
  FctsVector.Free;
  FctsVector := nil;
  CloseFile(FOutPut);
end;

procedure TestTctsVector.TestAdd;
begin
  Rewrite(FOutput);
  Writeln(FOutput, '-----------------Vector Add Begin----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector Add End----------------------');
end;

procedure TestTctsVector.TestClear;
begin
  FctsVector.Dispose := DisposeProc;
  Writeln(FOutput, '-----------------Vector Clear----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector Clear Add End----------------------');
  FctsVector.Clear;
  Writeln(FOutput, '-----------------Vector Clear End----------------------');
end;

procedure TestTctsVector.TestContain;
var
  ReturnValue: Boolean;
  AItem: System.Pointer;
  I: LongInt;
begin
  Writeln(FOutput, '-----------------Vector Contain----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector Contain Add End----------------------');
  AItem := Pointer(RandomRange(100000, 50000000));
  I := RandomRange(0, 20);
  Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(AItem)));
  FctsVector.Insert(I, AItem);
  Writeln(FOutPut, LongInt(AItem));
  ReturnValue := FctsVector.Contain(AItem);
  Writeln(FOutPut, BooleanNames[ReturnValue]);
  Writeln(FOutput, '-----------------Vector Contain End----------------------');
end;

procedure TestTctsVector.TestDelete;
var
  AIndex: System.Integer;
begin
  FctsVector.Dispose := DisposeProc;
  Writeln(FOutput, '-----------------Vector Delete----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector Delete Add End----------------------');
  AIndex := Random(20);
  Writeln(FOutPut, 'AIndex: ' + IntToStr(AIndex));
  FctsVector.Delete(AIndex);
  AIndex := Random(12);
  Writeln(FOutPut, 'AIndex: ' + IntToStr(AIndex));
  FctsVector.Delete(AIndex);
  AIndex := Random(8);
  Writeln(FOutPut, 'AIndex: ' + IntToStr(AIndex));
  FctsVector.Delete(AIndex);
  FctsVector.Dispose := nil;
  Writeln(FOutput, '-----------------Vector Delete End----------------------');
end;

procedure TestTctsVector.TestFirst;
var
  ReturnValue: IctsIterator;
begin
  Writeln(FOutput, '-----------------Vector TestFirst Begin----------------------');
  ReturnValue := FctsVector.First;
  Writeln(FOutput, 'First: ' + IntToHex(LongWord(ReturnValue), 8));
  ReturnValue := nil;
  Writeln(FOutput, '-----------------Vector TestFirst End----------------------');
end;

procedure TestTctsVector.TestGetArray;
var
  ReturnValue: PctsArray;
begin
  Writeln(FOutput, '-----------------Vector TestGetArray Begin----------------------');
  FctsVector.Add(nil);
  ReturnValue := FctsVector.GetArray;
  Writeln(FOutput, 'GetArray: ' + IntToHex(LongWord(ReturnValue), 8));  
  Writeln(FOutput, '-----------------Vector TestGetArray End----------------------');
end;

procedure TestTctsVector.TestIndexOf;
var
  ReturnValue: System.Integer;
  AItem: System.Pointer;
  I: LongInt;
begin
  Writeln(FOutput, '-----------------Vector TestIndexOf----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector TestIndexOf Add End----------------------');
  AItem := Pointer(RandomRange(100000, 50000000));
  FctsVector.Insert(RandomRange(0, 20), AItem);
  ReturnValue := FctsVector.IndexOf(AItem);
  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));
  Writeln(FOutPut, IntToStr(LongInt(AItem)) + ' in ' + IntToStr(ReturnValue));
  Writeln(FOutput, '-----------------Vector Contain End----------------------');
end;

procedure TestTctsVector.TestInsert;
var
  AItem: System.Pointer;
  AIndex: System.Integer;
  I: LongInt;
begin
  Writeln(FOutput, '-----------------Vector TestInsert----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector TestInsert Add End----------------------');

  for I := 0 to 5 do
  begin
    AIndex := Random(20);
    AItem := Pointer(RandomRange(100000, 50000000));
    FctsVector.Insert(AIndex, AItem);
    Writeln(FOutPut, 'AIndex: ' + IntToStr(AIndex) + ' | AItem: ' + IntToStr(LongInt(AItem)));
  end;

  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));

end;

procedure TestTctsVector.TestIsSorted;
var
  ReturnValue: Boolean;
begin
  Writeln(FOutput, '-----------------Vector TestIsSorted Begin----------------------');
  ReturnValue := FctsVector.IsSorted;
  Writeln(FOutPut, BooleanNames[ReturnValue]);
  Writeln(FOutput, '-----------------Vector TestIsSorted End----------------------');  
end;

procedure TestTctsVector.TestLast;
var
  ReturnValue: IctsIterator;
begin
  Writeln(FOutput, '-----------------Vector TestLast Begin----------------------');
  ReturnValue := FctsVector.Last;
  Writeln(FOutput, 'First: ' + IntToHex(LongWord(ReturnValue), 8));
  ReturnValue := nil;
  Writeln(FOutput, '-----------------Vector TestLast End----------------------');
end;

procedure TestTctsVector.TestPack;
var
  I: LongInt;
begin
  Writeln(FOutput, '-----------------Vector TestPack----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector TestPack Add End----------------------');
  for I := 0 to 4 do
    FctsVector.Insert(I, nil);
  for I := 16 to 20 do
    FctsVector.Insert(I, nil);
  Writeln(FOutput, '-----------------Vector TestPack Pack Begin----------------------');
  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));
  FctsVector.Pack;
  Writeln(FOutput, '-----------------Vector TestPack Pack End----------------------');
  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));
  Writeln(FOutput, '-----------------Vector TestPack End----------------------');
end;

procedure TestTctsVector.TestRemove;
var
  ReturnValue: Boolean;
  AItem: System.Pointer;
  I: LongInt;
begin
  FctsVector.Dispose := DisposeProc;
  Writeln(FOutput, '-----------------Vector TestRemove----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector TestRemove Add End----------------------');
  AItem := Pointer(RandomRange(100000, 50000000));
  FctsVector.Insert(RandomRange(0, 20), AItem);
  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));
  Writeln(FOutput, '-----------------Vector TestRemove Begin----------------------');
  ReturnValue := FctsVector.Remove(AItem);
  Writeln(FOutPut, BooleanNames[ReturnValue]);
  Writeln(FOutput, '-----------------Vector TestRemove End----------------------');
  FctsVector.Dispose := nil;
end;

procedure TestTctsVector.TestSort;
var
  I: LongInt;
begin
  Writeln(FOutput, '-----------------Vector TestSort----------------------');
  AddData;
  Writeln(FOutput, '-----------------Vector TestSort Add End----------------------');
  FctsVector.Compare := Compare;
  FctsVector.Sort;
  for I := 0 to FctsVector.Count - 1 do
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(LongInt(FctsVector[I])));
  Writeln(FOutput, '-----------------Vector TestSort End----------------------');
end;

procedure TestTctsLinkedList.AddData;
var
  I, Num: LongInt;
begin
  Randomize;
  for I := 0 to $FF do
  begin
    Num := RandomRange(100000, 50000000);
    Writeln(FOutPut, IntToStr(I) + ': ' + IntToStr(Num));
    FctsLinkedList.Add(Pointer(Num));
  end;
end;

procedure TestTctsLinkedList.SetUp;
begin
  FctsLinkedList := TctsLinkedList.Create;
  FFileName := ExtractFilePath(ParamStr(0)) + 'Logs\Ptr_LinkedList_Test.log' ;
  ForceDirectories(ExtractFilePath(FFileName));
  AssignFile(FOutput, FFileName);
  if FileExists(FFileName) then
    Append(FOutput)
  else
    Rewrite(FOutput);
//  Writeln(FOutPut, FFileName);
end;

procedure TestTctsLinkedList.TearDown;
begin
  FctsLinkedList.Free;
  FctsLinkedList := nil;
  CloseFile(FOutPut);
end;

procedure TestTctsLinkedList.TestAdd;
begin
  Rewrite(FOutput);
  Writeln(FOutput, '-----------------LinkedList TestAdd Begin----------------------');
  AddData;
  Writeln(FOutput, '-----------------LinkedList TestAdd End----------------------');
end;

procedure TestTctsLinkedList.TestClear;
begin
  FctsLinkedList.Clear;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestContain;
var
  ReturnValue: Boolean;
  AItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  ReturnValue := FctsLinkedList.Contain(AItem);
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestDeleteNode;
var
  aNode: PctsNode;
begin
  // TODO: Setup method call parameters
  FctsLinkedList.DeleteNode(aNode);
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestFirst;
var
  ReturnValue: IctsIterator;
begin
  ReturnValue := FctsLinkedList.First;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestGetHead;
var
  ReturnValue: PctsNode;
begin
  ReturnValue := FctsLinkedList.GetHead;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestGetTail;
var
  ReturnValue: PctsNode;
begin
  ReturnValue := FctsLinkedList.GetTail;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestInsertNode;
var
  AItem: System.Pointer;
  aNode: PctsNode;
begin
  // TODO: Setup method call parameters
  FctsLinkedList.InsertNode(aNode, AItem);
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestIsSorted;
var
  ReturnValue: Boolean;
begin
  ReturnValue := FctsLinkedList.IsSorted;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestLast;
var
  ReturnValue: IctsIterator;
begin
  ReturnValue := FctsLinkedList.Last;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestPack;
begin
  FctsLinkedList.Pack;
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestRemove;
var
  ReturnValue: Boolean;
  AItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  ReturnValue := FctsLinkedList.Remove(AItem);
  // TODO: Validate method results
end;

procedure TestTctsLinkedList.TestSort;
begin
  FctsLinkedList.Sort;
  // TODO: Validate method results
end;

procedure TestTctsStackVector.SetUp;
begin
  FctsStackVector := TctsStackVector.Create;
end;

procedure TestTctsStackVector.TearDown;
begin
  FctsStackVector.Free;
  FctsStackVector := nil;
end;

procedure TestTctsStackVector.TestPop;
begin
  FctsStackVector.Pop;
  // TODO: Validate method results
end;

procedure TestTctsStackVector.TestPush;
var
  aItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  FctsStackVector.Push(aItem);
  // TODO: Validate method results
end;

procedure TestTctsStackVector.TestTop;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsStackVector.Top;
  // TODO: Validate method results
end;

procedure TestTctsStackLinked.SetUp;
begin
  FctsStackLinked := TctsStackLinked.Create;
end;

procedure TestTctsStackLinked.TearDown;
begin
  FctsStackLinked.Free;
  FctsStackLinked := nil;
end;

procedure TestTctsStackLinked.TestPop;
begin
  FctsStackLinked.Pop;
  // TODO: Validate method results
end;

procedure TestTctsStackLinked.TestPush;
var
  aItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  FctsStackLinked.Push(aItem);
  // TODO: Validate method results
end;

procedure TestTctsStackLinked.TestTop;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsStackLinked.Top;
  // TODO: Validate method results
end;

procedure TestTctsQueueVector.SetUp;
begin
  FctsQueueVector := TctsQueueVector.Create;
end;

procedure TestTctsQueueVector.TearDown;
begin
  FctsQueueVector.Free;
  FctsQueueVector := nil;
end;

procedure TestTctsQueueVector.TestBack;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsQueueVector.Back;
  // TODO: Validate method results
end;

procedure TestTctsQueueVector.TestFront;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsQueueVector.Front;
  // TODO: Validate method results
end;

procedure TestTctsQueueVector.TestPop;
begin
  FctsQueueVector.Pop;
  // TODO: Validate method results
end;

procedure TestTctsQueueVector.TestPush;
var
  aItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  FctsQueueVector.Push(aItem);
  // TODO: Validate method results
end;

procedure TestTctsQueueLinked.SetUp;
begin
  FctsQueueLinked := TctsQueueLinked.Create;
end;

procedure TestTctsQueueLinked.TearDown;
begin
  FctsQueueLinked.Free;
  FctsQueueLinked := nil;
end;

procedure TestTctsQueueLinked.TestBack;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsQueueLinked.Back;
  // TODO: Validate method results
end;

procedure TestTctsQueueLinked.TestFront;
var
  ReturnValue: System.Pointer;
begin
  ReturnValue := FctsQueueLinked.Front;
  // TODO: Validate method results
end;

procedure TestTctsQueueLinked.TestPop;
begin
  FctsQueueLinked.Pop;
  // TODO: Validate method results
end;

procedure TestTctsQueueLinked.TestPush;
var
  aItem: System.Pointer;
begin
  // TODO: Setup method call parameters
  FctsQueueLinked.Push(aItem);
  // TODO: Validate method results
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTctsVector.Suite);
  RegisterTest(TestTctsLinkedList.Suite);
  RegisterTest(TestTctsStackVector.Suite);
  RegisterTest(TestTctsStackLinked.Suite);
  RegisterTest(TestTctsQueueVector.Suite);
  RegisterTest(TestTctsQueueLinked.Suite);
end.



